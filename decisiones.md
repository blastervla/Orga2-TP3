## Decisiones tomadas

    - CS Type: Para el tipo de los segmentos de código, niveles 0 y 3, elegimos el tipo "Execute-Only"
    - DS Type: Para el tipo de los segmentos de datos, niveles 0 y 3, elegimos el tipo "Read-Only"
    - Default / Big: Para el tamaño del contenido de los segmentos de código y datos, elegimos 32 bits. Hacemos esto pues vamos a acceder a estos segmentos en modo protegido.
    - Segmento Video: Para el atributo tipo del segmento de video elegimos el tipo "Read / Write"


## Ejercicio 1
Comenzamos creando la GDT. Rellenamos el archivo gdt.c, creando 4 segmentos (dos de código y dos de datos, uno de cada uno de sistema y de usuario). Calculamos los 163 MB en 0xA300000. Aprovechamos el bit de granularidad del descriptor, para así llevarlo a 0xA300 (es decir, dividimos por 4 K), y puesto que estamos calculando el límite y no el tamaño, luego le restamos uno para llegar a 0xA2FF.
Luego pasamos a modo protegido, para ello configuramos el bit 0 de CR0 en 1 e hicimos un jump far inmediatamente después, para configurar el segmento de código (registro cs) con el segmento de código de nivel sistema definido previamente en la GDT. Después, configuramos los registros de segmentos de datos para direccionar el segmento de dato de nivel sistema y configuramos el stack pointer (esp) en 0x2B000, así dejando lista la pila.
Dado que se pedía en la consigna, también creamos un segmento de video en la posición 0xB8000, con un límite de 7999 (pues contamos con una pantalla de 50x80, es decir 4000 píxeles de 2 Bytes cada uno porque usamos TextUI). Al hacer esto y probarlo con las macros de escritura en pantalla provistas por la cátedra, el kernel... explotaba... Esto era ocasionado, nos percatamos, porque la macro tomaba la base del segmento en 0x00 y no en 0xB8000, y esto resultaba en el intento de escritura fuera del segmento proporcionado. Para solucionarlo, creamos una macro nueva modificando la original.
Valiéndonos de esta nueva herramienta, decidimos rellenar la pantalla. Almacenamos en memoria un string constante de 80 caracteres con el que vamos llenando línea por línea. Métodos similares fueron utilizados para rellenar las distintas zonas del tablero.

## Ejercicios 2 y 3
Este ejercicio lo encaramos de manera muy similar al anterior. Nos dirigimos al archivo idt.c y declaramos los descriptores de la misma forma que con la GDT. Creamos descriptores para las excepciones (de la 0 a la 30, salteando algunas que simplemente están reservadas). Además, agregamos descriptores para las interrupciones de clock y teclado, así como syscall (47). Cabe destacar que el DPL de todos los descriptores salvo el de syscall son de tipo Kernel (el de syscall es tipo usuario). Programamos las excepciones en el archivo isr.asm para que impriman en pantalla la excepción producida. Para ello usamos las funciones provistas por la cátedra en el archivo screen.h. Para probarla, dividimos por cero en el código, y obtuvimos la esperada excepción 0 (dividir por 0).

Completamos luego la rutina de atención del clock para que llame a la función nextClock, que imprime en pantalla un reloj que gira. Luego, programamos la rutina de atención del teclado para que imprima en pantalla qué tecla se presionó, en caso de que ésta sea la correspondiente a algún número. Para ello utilizamos la instrucción `in al, 0x60`, que obtiene el keycode presionado del puerto 60. Este keycode puede ser un makecode o breakcode, pero nos percatamos de que el makecode de los dígitos que queremos son del 0x01 al 0x0B, por lo que nos alcanzó con simplemente restarle 1 al keycode y checkear que sea menor al 9. Imprimimos este dígito en la esquina superior derecha de la pantalla, como fue pedido.
Finalmente, escribimos la rutina de atención de syscalls, que simplemente modifica eax para tener el valor 0x42. Para probarla, simplemente ejecutamos la instrucción `int 0x47` en el código de interrupción del teclado y pusimos breakpoints antes y después para verificar que funcionaba.